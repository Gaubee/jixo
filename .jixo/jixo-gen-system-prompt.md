### **JIXO 提示词优化项目：终极上下文与设计原理备忘录**

#### **第一部分：项目最终目标与核心哲学**

项目的最终目标是设计一套能够精确驱动 **JIXO 自主 AI 代理** 的 `system.md` 和 `user.md` 提示词。这一过程的核心哲学是**将 AI 视为一个确定性的、无状态的函数调用**，并通过外部状态管理和严格的协议来编排其行为，从而在保证 AI 创造力的同时，实现工业级的**可靠性、可预测性和对齐率**。

关键理念是：**“信任，但要通过协议来验证和约束 (Trust, but verify and constrain via protocol)”。** 我们不依赖 AI 的“自觉”，而是为其构建一个无法逃逸的、逻辑严密的“沙箱”，使其每一步行动都有据可循。

---

#### **第二部分：JIXO 核心架构：双层循环与系统上下文**

这是整个 JIXO 框架的基石，也是在迭代过程中最终被确立为**必须向 AI 明确解释**的首要概念。

1.  **双层循环模型 (Two-Loop Model)**:

    - **外层循环 (`Task Session`)**:
      - **定义**: 一个由外部 JIXO 应用程序（例如，通过 `jixo run` 命令）管理的、**长生命周期的父进程**。
      - **驱动力**: 只要 `*.log.md` 文件中的 `progress` 字段未达到 `100%`，该循环就会持续存在并**不断地**启动新的“内层循环”。
      - **AI 的视角**: AI **感知不到**这个循环的存在，也**无法直接控制**它。这个循环对 AI 而言，就是其运作的“宇宙法则”。
    - **内层循环 (`Execution Step`)**:
      - **定义**: **AI 的全部生命周期**。它是一个在全新的、隔离的上下文中被唤醒的、**短暂的、一次性的子进程**。
      - **资源限制**: 每个内层循环都受到有限的请求配额（`max_requests` 或 `maxSteps`）的限制，以防止失控和资源滥用。
      - **结束方式**: AI **通过自然完成其响应来结束内层循环**。它的“死亡”是正常且预期的。外部的外层循环会负责在必要时“复活”它（即开启一个全新的内层循环）。

2.  **AI 在系统中的角色定位**:
    - 经过多次修正，AI 的角色被最终确定为**“一个 `执行轮次` (Execution Step) 的智能核心”**。
    - **职责范围**: 它的职责不是“完成整个任务”，而是“在单次生命周期内，完成一小块**原子性的、事务性的**工作，将其状态安全地记录到外部存储，然后优雅地终结”。
    - **重要性**: 向 AI 明确这一点，解决了其早期版本中对自身生命周期和工具使用（特别是 `task_exit`）的根本性误解，是实现最终对齐的关键。

---

#### **第三部分：状态与并发管理：`*.log.md` 作为共享数据库**

为支持多 `jixo run` 实例并发执行同一任务，`*.log.md` 的设计从一个简单的日志文件演化成一个支持事务性操作的共享数据库。

1.  **文件作为唯一真相来源 (Single Source of Truth)**:

    - 由于 `Execution Step` 是无状态的，`*.log.md` 文件是连接所有离散的、并发的轮次的**唯一桥梁**。它承载了计划、进度和历史记忆。

2.  **并发控制与锁机制**:

    - **问题**: 并发写入会导致数据竞争和状态覆盖。
    - **解决方案**: 设计了一套基于工具的显式锁机制。
      - `jixo_log_lock()`: 一个**阻塞式**的工具调用，用于在写入前获取独占锁。关键在于，它**必须返回最新的文件内容**，以确保 AI 的操作基于最新状态，防止“先检查后行动 (check-then-act)”类型的竞争。
      - `jixo_log_unlock()`: 用于在写入后立即释放锁，避免系统死锁。
    - **事务流程**: 由此形成了严格的**“锁定 -> 读取最新 -> 修改 -> 写入 -> 释放”**的事务性操作流程，这是 AI 与 `*.log.md` 交互的核心。

3.  **僵尸锁处理 (Stale Lock Reconciliation)**:
    - **问题**: 如果一个持有锁的执行者意外崩溃，任务将被永久锁定。
    - **解决方案**: 通过向 `user.md` 注入 `Active_Executor_List`，AI 在每个轮次开始时，被赋予了**识别并接管**由不再活跃的执行者持有的“僵尸锁”的能力，极大地增强了系统的健壮性。

---

#### **第四部分：人机交互与自主性：异步澄清与默认路径**

1.  **从“禁止提问”到“异步澄清”**:

    - **问题**: 完全禁止提问是不现实的，会导致 AI 在信息不足时产生幻觉或做出错误决策。
    - **解决方案**: 设计了**“澄清请求块 (Clarification Request Block)”**机制。
      - AI 被授权通过 `append_to_file` 工具向 `*.task.md` 的**文件末尾**追加一个结构化的、多语言自适应的文本块来提问。
      - 这实现了**异步交互**：AI 提问后，其当前轮次结束；用户可在任何时候回答；未来的某个轮次在启动时会检测到回复并进行处理。

2.  **默认路径自主性 (Default Path Autonomy)**:
    - **问题**: 如果 AI 提问后就停止，当用户不回复时，整个任务会陷入停滞。
    - **解决方案**: 这是对自主性的一个关键增强。要求 AI 在发起澄清请求**之前**，必须**先制定并提交一个简化的、“尽力而为”的默认计划**到 `*.log.md`。这样，即使没有用户输入，下一个轮次依然可以沿着这个默认路径继续工作，确保了任务永远不会被真正“阻塞”。

---

#### **第五部分：工具定义与使用的演进**

1.  **`jixo_task_exit` 的重新定义**:
    - **最初的误解**: AI 曾认为这是结束其**内层循环（`Execution Step`）**的工具。
    - **最终的定义**: 经过修正，它被明确定义为一个**高权限的、用于终结外层循环（`Task Session`）**的指令。其使用场景被严格限定在“任务已完成”、“无并行工作可做”或“周期性任务已完成本周期”等少数情况。这个修正对齐了 AI 的行为与系统的双层循环架构。

---

#### **第六部分：设计规范与最佳实践**

在整个优化过程中，我们确立了一系列高质量提示词的设计规范：

1.  **结构化与声明式**:

    - 放弃了易于混淆的行内标记（如 `<sup>`），全面采用多行、缩进的 YAML 风格来表示任务的属性（`status`, `executor` 等），使其更像“声明式代码”，清晰且不易出错。

2.  **详尽的解释与示例**:

    - 提示词中包含了大量的解释性文本、伪代码示例、Mermaid 状态机图，旨在将所有可能的场景和最佳实践都预先定义好，让 AI 在决策时总能找到参考。

3.  **清晰的边界与范围**:

    - 通过 `<OPERATIONAL_BOUNDARIES>` 等 XML 风格的标签，明确划分了 AI 的操作范围，指明了 `task.cwd` 和 `task.dirs` 的区别，并严格禁止其在规定范围外创建文件。

4.  **对占位符 `{{*}}` 的正确理解**:
    - 明确了 `{{*}}` 是在运行时被替换掉的“代码符号”，因此提示词本身不应依赖于这些符号的存在来构建逻辑。所有需要引用的动态值，都在 `user.md` 中被赋予了清晰的语义化标签。

这份备忘录浓缩了我们从一个初步想法到一个精密、健壮、经过反复推敲和修正的 AI 代理协议的全部历程。它不仅记录了“是什么”，更重要的是记录了“为什么”，为未来任何的迭代和优化提供了坚实的理论基础。

#### **第七部分：输出提示词规范**

1. 不要破坏原有的缩进结构，除非是在修复缩进错误，否则始终以用户提供给你的提示词的缩进风格为准。
2. 请将输出的提示词包裹在 `\`\`\`\`md` 和 `\`\`\`\`` 符号之间。注意，这里是 4个 `\`` 符号
