以下是目前最新的代码，请基于此继续开发：

[`packages/mcp-fs/src/**/*.ts`](@FILE)

---

我们的目标是对mcp-fs做一次比较彻底的重构和优化。

目前的mcp-fs是提供了一个工具，让AI能读写某些文件夹里的文件。用法大概是：

```bash
mcp-fs /dir1 /dir2 # 读写 dir1 和 dir2
mcp-fs /dir1 /dir2 /dir3 --read-only # dir1 、 dir2 、 dir3 完全的只读模式
```

这次的升级，我将引入一些新的功能和用法，同时尽可能和原版兼容：

1. 引入cwd理念，这样在操作 `./main.txt` 这种相对路径时，会自动定位到 `$CWD/main.txt` 下，更加方便AI操作
   1. cwd是可以通过指令读改的，也就是 `fs_set_cwd` 和 `fs_get_cwd`
1. 引入挂载的理念： `mcp-fs /dir1 /dir2 /dir3` 本质上就是在挂载三个文件夹，如果文件夹的路径很长，那么挂载就有了意义：
   1. liunx 是通过 mount 命令挂载到 `/mnt/`下，当我们的挂载是在`mcp-fs`执行的时候就完成挂载了，为了避免AI的幻觉，我们使用`$A/`、`$B/` 这样的特殊盘符来替代。
   1. 比如说 `mcp-fs /dir1/is/long/path /dir2/is/long/path` 那么 `$A` 默认就是 `/dir1/is/long/path`， `$B` 默认就是 `/dir2/is/long/path`
   1. 并且一开始 `$CWD` 指向第一个挂载的路径，也就是`/dir1/is/long/path`，等于 `$A`
   1. 另外，如果有需要，可以指定盘符：`mcp-fs $C=/dir1/is/long/path $D=/dir2/is/long/path`，同时意味着 `$CWD=$C`
      1. 这里的盘符分配逻辑，使用默认顺位的逻辑：默认开始是`A`，后续若果没有配置，就沿着这个顺序往下，如果有配置，比如指定了`D`，那么就挑转到 `D`，往后的默认顺位就是`E/F/G`这样顺位下去，直到有新的指定。
      1. 比如有一个突然跳转回了`C`，那么默认顺位就回到了`D/E/F/G`，这个过程中，如果有冲突（一个盘符被不同的文件夹（realpath）多次使用，但是允许同一个文件夹使用多个盘符），就要报错，需要用户自己调整配置。
1. 引入独立权限配置的功能：`mcp-fs [R]=/dir $C[W]=/dir`
   1. 语法大概就是由`[]`包裹，里头使用 URL-queryString 的语法解析即可，目前只有 `[R]` 和 `[W]` 两个参数，分别表示读权限和写权限。默认不配置，就是`[R&W]`两个权限都给。
   1. 注意，因为引入了复杂的权限控制，而这些文件夹可能是有交叉的，因此需要在底层构建一个权限树，或者hash表，做读写之前需要先做权限查询：
   1. 比如说 `/a/b/c/d/e.md`这个文件的权限查询，需要逐个向上查询：`/a/b/c/d` 是否有权限，找不到就继续`/a/b/c`是否有权限，否则继续`/a/b`，否则继续`/a`,否则就是这个文件夹没有配置，就没有任何的访问权限。
   1. 这种权限的查询方式，就意味着假设我配置了`mcp-fs [R]=/a/b/c/d [R&W]=/a/b/c [R]=/a/b/`，构建出来的权限树就是：`/[R]a/[R]b/[R&W]c/[R]d`，也就是说除了`/a/b/c/d`只读，`/a/b/c`下的其它文件文件夹都是可读写的。
1. 最后，还应该有一个查询挂载信息的接口`fs_list_mount`
   1. 这个接口返回挂载的路径，盘符、权限信息
   1. 最好是根据路径做好排序后返回。

以上就是我的目标，请你审视补充，给我一些意见，然后生成一份计划书
