# 研发报告：Groq 通信层现代化重构

**日期**: 2025-08-08
**项目代号**: `groq.meta`
**核心贡献者**: 首席架构师, AI 软件工程师

---

## 1. 问题陈述：旧范式的“熵增”

在本次重构前，`groq` 模块的 Node.js-Browser 通信层依赖于一个基于**异步生成器 (`async function*`)** 的复杂模型。其核心问题（即“熵”）体现在 `browser/sync.ts` 中的主循环。

- **控制流与业务逻辑的强耦合**: `sync.ts` 的 `while` 循环负责驱动生成器 (`taskProcessor.next(nextTask)`)，而 `doFetch`/`doEval` 内部则通过 `yield` 被动地交出控制权。这种断裂的、相互依赖的执行流使得代码难以理解、调试和维护。
- **状态同步的脆弱性**: 通信依赖于同步完整的 `Task` 对象，这既不高效，也容易因状态不一致而出错。
- **资源管理的风险**: 异步生成器的生命周期管理复杂，存在因异常未被正确捕获而导致文件句柄或计时器泄漏的风险。

## 2. 核心洞察与范式转移

我们应用了“第一性原理”和“分层”的思维工具，对问题进行了深度剖析：

- **`fs-duplex` 的本质**: 它是一个**基础设施/传输层**，其唯一职责是提供一个可靠的、有状态的、一次性的任务信道。使用者不应再关心底层的连接和消息传递。
- **`groq` 任务的本质**: 它是一个**应用层协议**，定义了为完成特定业务（如 `fetch`）而需要分步交换的信息。

基于此洞察，我们进行了一次彻底的**范式转移**：

**从“被动生成器”模式，转向“主动服务循环”模式。**

新范式的核心思想是：

1.  **控制权反转**: 浏览器端的 `doFetch`/`doEval` 成为一个主动的服务，拥有自己的控制流。
2.  **指令式通信**: Node.js 端不再同步状态，而是发送轻量级的**指令 (Commands)**，如 `getFullBody` 或 `requestChunk`。
3.  **分层解耦**: `fs-duplex` 全权负责传输，而 `doFetch`/`doEval` 只需专注于业务协议本身，通过我们发明的 `waitNextTask` 工具线性地、可预测地等待指令。

## 3. 解决方案：重构执行概要

我们通过一个分为三步的精确计划，完成了本次重构：

1.  **奠定基础**:
    - ✨ **发明 `waitNextTask`**: 创建了 `common/utils.ts`，提供了这个带有超时和关闭处理的核心工具，它是新范式的基石。
    - ♻️ **更新接口契约**: 修改了 `doFetch`/`doEval` 的函数签名，为新逻辑铺平了道路。

2.  **重构核心循环**:
    - 🏗️ **简化 `browser/sync.ts`**: 废除了旧的 `while` 循环和生成器驱动逻辑，替换为一个极其简洁和健壮的 `try...finally { duplex.destroy() }` 结构。
    - 💪 **强化状态管理**: 将 `active_tasks` 的清理工作绑定到 `duplex.onClose` 事件，从根本上杜绝了资源悬挂。

3.  **适配应用逻辑**:
    - ✅ **实现 `doEval`**: 将其重构为一个简单、线性的 RPC 实现。
    - ✅ **实现 `doFetch`**: 实现了“主动服务循环”，并基于“拉取”模式构建了内存高效的流式传输。
    - ✅ **重构 `BrowserResponse`**: 更新了 Node.js 客户端，使其能够发送新协议中定义的指令。
    - 🔥 **清理技术债**: 删除了无用的 `common/coding.ts` 文件和 Zod 定义中的废弃字段。

## 4. 成果与展望

本次重构取得了显著成果：

- **熵减**: 代码的复杂性大幅降低，变得线性、可读、易于维护。
- **健壮性**: 新的错误处理和资源管理机制确保了系统的稳定性。
- **性能**: 流式传输的实现解决了大数据量下的内存溢出问题。

`groq` 模块的通信层现已达到现代化标准，为未来功能的扩展奠定了坚实的基础。
