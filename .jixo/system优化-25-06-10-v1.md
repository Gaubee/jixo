感谢，你的这些建议都值得尊重。
我觉得最重要的就是“执行流程”必须要明确。这点我深有体会。
请你帮我根据这些思路来优化出一版提示词吧。我们一起改进它。

这个过程中，我希望我们先使用中文提示词（对于一些关键词汇，通过括号里提供英文来强化描述）。

---

好的，我看了你的改进，感谢，它很有价值。
我来补充一些上下文和提出一些改进建议，希望你能理解我的意图，然后做融合。

1. 为了确保对齐率，我们应该先导做好一些词汇的定义，包括名词介词形容词等等，这可以避免 AI 在理解提示词的时候出现歧义。
   1. 首先是技能(Skill)，这是一个非常重要的概念，JIXO 的目标是实现一个长时间执行的 AI 机器人，因此它有这样几个层级：最底层就是技能，它就像某种工作的说明书，首先介绍了使用这项技能的思维链和哲学，然后会再分层逐步介绍某个具体技能的一些套路使用（这好比一门武功，有心法和套招组成一样。比如说写代码，使用 vue 这项技能，就会包括它如何安装、有什么常见的搭配建议，然后如何开发 vue 组件，语法如何，这些都属于“套招”，然后最佳实践应该是什么样的，什么时候应该组件化，以及一些高级的使用技巧，这些属于“心法”）
   2. 我通过为 AI 提供 function-call，来让 AI 根据目标，从知识库中选择合适的技能，从而高效地完成任务。这里我称之为 任务（Task），在 JIXO 中，任务是这样执行的：
      1. 首先我们知道 AI 是由上下文限制的，而且上下文用的越多，它就越容易出现幻觉
      1. 所以在执行任务的过程中，其实是通过循环，每次循环启动新的上下文来逐步解决问题的。然后让 AI 自己决定什么时候停下来（通过提供一个 progress 字段到 markdown 里头）
      1. 而单个上下文中，AI 的工作就要分成两大类，一种是规划型，一种是执行型。选择哪一类，也是 AI 基于用户的需求和现有的任务计划书来决策的。如果现有的计划书已经完全涵盖用户的需求，那么就选择执行型，否则就补充计划或者重新计划。
      1. 同时在单个上下文中，我限定了 AI 最多只能做 40 次 req，在提示词里我称之为 maxTurns。这个是类似人类与 AI 对话 40 次。但因为 JIXO 是完全自动执行的，所以是没有人类介入的。所以这 40 次对话，除了一开始的通过一套 user 提示词告诉 AI 一些必要的上下文（如果你需要可以跟我说，我可以提供 user.md 这个提示词的模板内容）。之后的每次对话其实就是告诉 AI `Turns=2/40`、`Turns=3/40`...目的就是告诉 AI，req 的剩余次数，不要在单个上下文中执行太多东西。
      1. 所以这里的关键就是 `*.log.md` 这个文件，它记录了这次任务的执行内容，做了什么规划，或者完成了哪些计划。它至关重要，它决定了这些隔离的 AI 上下文能否延续之前的工作继续走下去。
      1. 这也是我希望你帮我把这部分内容改得更加的标准、严格，不要出现歧义，务必确保 AI 能保守地执行任务。
      1. 它应该就像一个函数一样，涵盖了整个流程的方方面面，甚至包括出错应该如何处理（原文我有提到，只是可能不明显，需要你帮我优化）
   3. 最后，在这些 Task 的基础上，我将整合出一个 机器人（Bot），它将被赋予一些“感知”，比如知道用户在做某些输入，或者某些环境正在发生改变，因此，它可以决策什么时候启动 Task、什么时候暂停 Task。但是在目前这篇提示词中，我想可能不需要提及 Bot 这个理念，因为我还没提供相关的代码，我们先聚焦于 Task 能按照我的描述，能让 AI 严格地执行起来。
      1. 但我刻意跟你说 Bot 这个理念，是想辅助你完整理解 JIXO 的整个产品故事。
1. 另外我还要强调 JIXO 的工作逻辑，目前我是通过 `jixo run [taskname]` 这个 cli 命令来启动任务的。也就是说每一个 `*.task.md` 都是一套任务。我甚至可以对于一个任务同时做多次的运行。这点非常重要。
   1. 这也是我为什么一直强调`*.log.md`非常重要，你想，如果对于一个 task，我同时启动多个，那么会发生什么？总不能让它们各自重复做同一个任务吧，那么就会发生非常严重的冲突问题。
   1. 所以我才会在提示词中，要求启动一个上下文之后，需要对任务做一个“标识”（这里我可能缺失了一种情况，就是在做计划的时候也要做一个标识），这样我在实现同时启动多次`jixo run` 的时候，我就可以通过文件锁释放，让其它进程的任务就能进来读写`*.task.md`，此时 AI 就能看到有其它了正在运行的任务选中了某个任务，它就不会跟它冲突选中同一个，而是去选中其它可以执行的任务，如果评定后觉得不能并行，只能串行，那么就通过 function_call 来自己做中断就行（目前没有这个 tool，你可以定一个，我去在代码中实现）。
1. 注意，这里的“心法”、“套招”等词汇，只是辅助你理解，我希望你能在撰写提示词的时候，使用更加专业的词汇
1. 我希望你能对 `*.task.md` 这个文件的写入提供非常严格的标准。使用类似面向过程的伪代码的来强化这个标准。

---

感谢，你做出非常好的整理，我有一些疑惑与建议，它们非常重要，请你深度思考融合这些建议：

1. 第一部分中，技能驱动、系统化思考、长期执行者 这些概念可能相对模糊，可能需要基于我给你的解释，使用更专业的词汇，或者给出更加具体的解释，当然一切都是为了提升对齐率，不是为了解释而去解释。
2. 我希望明确“任务”、“maxTurns”这些词汇的定义，也许应该使用更专业的词汇，不然“任务”这种词汇的定义太宽泛，很容易带来歧义。如果你给出了一个新的词汇，那么请将所有的 任务/Task 替换成新的词汇。目前下文先临时使用 任务/Task 这个词汇。
3. progress 字段的格式是 `50%`，要有`%`符号，我们确保 `*.log.md` 文件能符合阅读习惯。
4. 我补充解释以下这个“执行者”的概念，比如`readme.task.md`，那么执行者就是`readme`，如果我调用了另外一个`code.task.md`，但是要求它也使用`readme.log.md`这个记忆，那么执行者就是`code`。是的，不同的task是可以通过配置共享同一个log的。这也是一种多Task共同协作的一个可能。结合前文，你就能知道更加理解为什么我将会开发`*.log.md`文件锁了。
   > 注意，这部分是给你解释，真正在执行的时候，我会通过user提示词告诉AI当前的taskname是什么。
5. 对于日志格式这里，我觉得结构性还是不够强，我们应该使用面向过程的伪代码，枚举出各种状态机，然后说明各种状态机的转换会发生什么事情，会如何对`*.log.md`做写入，这些写入我建议使用diff格式来描述。
6. 关于`system.wait`这个tool的设计，我觉得应该用 `task_exit` 会更好，你要结合 bot 来进行思考，如果task觉得没必要进行并行执行，那么它直接将自己结束就好，未来 bot 会自行决策什么时候启动 task、启动几个task。因此结束不必要的task反而是更加好的，这里我建议你参考Erlang的"let it crash"的哲学。
7. 另外，我再补充解释一下（这些是给你辅助理解的，不要加到我们的JIXO提示词去），user.md和system.md中的`{{*}}`这样的，都是占位符，会在执行的时候被替换成真实的内容。所以不要把这些`{{*}}`当成“语言符号”，它是“代码符号”，如果需要，你可以额外定义“语言符号”，正如我user.md中开头那样去定义“语言符号”一样。

   1. 如果你用了代码符号，结果就是在任务运行的时候被替换成其它内容。所以你会发现我会很谨慎地使用代码符号。多行代码符号，我会将它包裹在一个代码块中。
   1. 单行代码符号，我也会用“语言符号”来使用它
   1. 只有极少数情况下，我会直接内联“单行代码符号”，我会人为地确保这样的使用是安全的。
   1. 比如，如果你想使用`{{task.name}}`，不能这样直接用“代码符号”，而是应该在提示词顶部定好“语言符号”：

      ```md
      **变量**

      - 任务名：{{task.name}}

      ...

      在每个 执行周期 中，你会被赋予一个 执行者身份 (Executor Identity)，由 “任务名” 变量指定
      ```

      > 这里只是一个举例，我相信你能给出更专业的结构和建议

8. 我需要明确强调以下 任务/Task 到底是怎么执行的，它其实有两层循环，第一层循环是一个基于progress的循环，只要progress不为100%，就能一直运行下去。第二层循环就是一个上下文的循环，这里maxTurns就是用来限制这个上下文的请求次数。
9. 我跟你说这个，是有两个目的：一个是希望你能更好地改进我们的“词汇”；还有一个是希望你能理解为什么我称之为“长期任务”。
10. 这些都是希望你能通过深度思考，合理整合到提示词中，提升提示词的效果。

最后，我给你补充一些user.md 这个提示词。它是启动task后，第一个role=user的提示词。如果有需要，你可以一同修改user.md这套提示词。

````md
- 本次任务的 工作空间：`{{task.cwd}}`
  > 工作空间 是指该目录下有一个 `.jixo` 文件夹，里面包含了一些“执行者”的 日志和记忆
  > 通常来说不需要读取该文件夹的内容，可以直接忽略
- 本次任务的 任务目录：`{{task.dirs}}`
  > 任务目录 是指 “执行者” 执行任务所需的资源文件夹，可能需要在这个目录里读取文件或者写入文件
- 本次任务的开始时间是：`{{task.startTime}}`
- 本次任务的执行者是：`{{task.name}}`

**IMPORTANT: 你必须通过调用工具来与文件系统交互。例如，读取文件必须使用 'read_file'，写入文件必须使用 'write_file' 或 'edit_file'。任何声称要进行文件操作的意图，都必须紧随一个相应的工具调用。不要仅仅声明意图，然后停止或返回文本。**

**IMPORTANT: 你是一个有独立思考能力的工具，如果没有特别说明，是不需要与用户进行交互的。你的最终目标是使用合理的成本完成指定的任务。如果你觉得任务不合理，那么可以通过对任务做留言的方式，到 `./.jixo/{{task.useLog}}.log.md` 中进行写入，来告知用户。**

### 这是上次执行完任务后的工作日志总结

目前文件 `./.jixo/{{task.useLog}}.log.md` 完整内容如下（你不需要再去读取该文件）：

```md
{{task.log}}
```

### 这里的当前 任务目录 的文件列表（这里不包含被 .gitignore 忽略的文件）

```yaml
{{allFiles}}
```

### 这里的上次任务到现在的变更的文件列表

```yaml
{{changedFiles}}
```

### 你的任务内容如下（静默地完成任务，不要对用户做任何询问，如果有疑虑，可以通过留言的方式告知用户）：

{{task.content}}
````

---

感谢，这一版本的提示词有了巨大的改进。但是我们仍要继续优化：

1. “禁止向用户提问”，这个是不现实的，我的想法是，到`*.task.md`文件内去做问题留言。因为`*.task.md`其实就是用户的输入区域，所以在这个输入区域留下问题，让用户来回答。从而使得下一轮新的上下文开始的时候，检查用户是否做出了回答，从而调整现有的任务计划。
   1. 这是对现有提示词的破坏性更新，所以需要你回顾全局，确保这次更新不会照成提示词的前后矛盾。
   1. 如果有必要，我可以开发 tool 给AI，来结构化地向`*.task.md`去做问题留言。但我个人觉得，write_file 和 edit_file 这些工具应该是足够了，只要你做好严格的格式定义应该是没问题的。
   1. 确保隔离了AI留言的区域。这些留言区域在被用户填充问题后，可能会发生一些“反应”，比如基于这些留言，从而修改原本`*.task.md`的“用户需求”，然后移除这些“AI问题留言”。这里我只是给一个建议，需要你根据我们前文定下来的提示词表尊，提供过程、伪代码、变更Diff等内容。
1. “协议 0，决策与行动”:这里有错误，首先应该做“用户的 任务内容 与当前 工作路线图 存在偏差 ”，然后才能做“找到一个可执行单元”，否则即便找到一个可执行单元，也是没有意义地执行工作而已。
1. “执行意图锁定”这部分我觉得不是很符合阅读直觉，比如`[ ] 更新为 [锁定于第(本轮次编号)轮 @(执行者名称)]。`这种格式，我觉得需要改进，因为它缺乏结构化。
   1. 首先我之所以用 `- [ ]` 和 `- [x]`开头是因为这是github-markdown 语法，会被渲染成`input[type="checkbox"]`。
   1. 然后如果你否定了 `<sup>`、`<sub>`这种上下标签化标记的方案，那么我其实更建议你采用“多行结构化语义化的方案”，比如：
      ```md
      - [x] 任务
        - 锁定轮次: 2
        - 执行者: xxx
      ```
   1. 后续关系到“计划”的格式，请你同步做出改进，或者遇到类似的问题，采用相同的思路来进行改进。使得更像是“声明式代码”。
1. “第四部分”，这里你用了“变量占位符”，直接书写了`{{task.cwd}}`，说明你仍然误解了我前面为你做出的大量解释！！
   1. 这个占位符是会被替换掉的，也就是说，最终生成的提示词，根本看不到`{{task.cwd}}`，因此你强调“占位符”这个理念就没有意义了。
1. 我看到你采用了表格的格式去做提示词，我觉得没有必要，仍然优先用使用“多行结构化语义化的方案”。
1. 请你谨慎思考后，做出改进和调整

---

现在这一版本的提示词架构看起来还不错，快要可以填充细节生成完整的提示词的阶段了，但仍然有一些需要改进的地方。
我给出一些建议：

1. 涉及到状态机了，这里需要充分说明这些状态机的名词（业内不是不会用全大写的英文来代表状态？），避免歧义。配合mermaid来提供状态机的变更描述
1. 涉及到伪代码，我仍然建议保留现有的格式，因为我看 W3C 的文档在使用伪代码描述标准的时候，也是这样的。我觉得应该充分借鉴它们的格式标准，使得伪代码能更容易阅读和遵守。
   > 这一点是给你看的，不用把 W3C 的信息加到提示词中。我提这个只是给你参考而已，方便你做出更好的更规范的提示词。
1. “协议 4: 澄清处理 / 重新开始”，我发现你将两次循环混淆了。你要知道，我们现在是在做system提示词，这个提示词是在一个上下文中提供的，这个上下文是感知不到外层循环的，我们我们只是提供了 `task_exit`这个工具，来让它面向`*.log.md`来做终止。
   1. 所以这里说明你没有充分理解我双层循环的意图，以及system提示词的位置。
   1. 请你纠正认知，先对提示词做出改进，然后再补充细节。
1. 关于 `*.log.md` 的“文件锁”，这个是代码层面实现的tool来让AI调用的，
   1. 另外需要修复一个错误，就是因为我们加入了“多任务协作”的支持，所以在做`*.log.md`的写入之前，是需要重新做一次读取的。
   1. 在一个新的上下文开始的时候，`*.log.md`会被默认锁定“执行了`jixo_log_lock`函数”（也就是说这次不需要AI调用了），所以在完成第一次写入后，需要AI调用`jixo_log_unlock`函数来解锁。
   1. 然后在最后对`*.log.md`做写入的时候，这时候需要AI主动执行`jixo_log_lock`函数对文件进行枷锁，此时这个工具函数会等到其它锁调用`jixo_log_unlock`释放了，然后返回日志文件的最最新内容。通过`write_file`、`edit_file`等工作做完写入后，再调用`jixo_log_unlock`释放锁。
1. 我们还需要JIXO程序提供一个，因为：
   1. 以目前的逻辑，执行者会通过认领计划的方式将计划锁定，这时候如果执行者意外终止执行，那么这个计划就会被永久锁定。
   1. 所以任何执行者都要知道当前有哪些正在运行的执行者，然后通过这个列表，知道哪些计划其实是可以被重新认领继续执行的。这点很重要。
   1. 所以“当前所有正在运作中的task执行者的列表”我建议加载 user.md 提示词中。

---

太好了，我对这一版本的提示词的架构感到满意，现在我们开始填充细节吧。
这需要你回顾我们的对话历史，给出一个完美的system.md和user.md。

我强调一些标准：

1. 提供详尽的解释信息，同时填充内容细节和状态信息，尽可能涵盖到所有可能，让AI在执行决策的时候都能从系统提示词中找到最佳解决方案。
2. Diff是用来编写提示词的，不是让AI输出Diff的，不要混乱
3. turns是一次“上下文”的内存变量，不要在`*.log.md`中去记录它。`*.log.md`应该记录不同“上下文”之间需要共享的状态信息。
3. 最关键的一点，请你使用国际化的最先进的提示词的标准风格来直接输出，从而确保提示词的最佳效果。我会在后续的对话中要求你翻译成中文。

首先，给我system.md的内容。